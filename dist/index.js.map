{"version":3,"file":"index.js","mappings":"mBACA,IAAIA,EAAsB,CCA1BA,EAAyBC,IACxB,IAAIC,EAASD,GAAUA,EAAOE,WAC7B,IAAOF,EAAiB,QACxB,IAAM,EAEP,OADAD,EAAoBI,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,CAAM,ECLdF,EAAwB,CAACM,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXP,EAAoBS,EAAEF,EAAYC,KAASR,EAAoBS,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDR,EAAwB,CAACc,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,ICA7CI,QAAQ,kBAA7C,MCAM,EAA+BA,QAAQ,S,aCARA,QAAQ,eAA7C,MCAM,EAA+BA,QAAQ,c,ICCjC,EAUA,EAMAC,EAYAC,EAlBAC,EAVAC,E,SCmCwB,IAAI,IAAJ,CAAO,KClC3C,WAAe,CACbC,UAAW,GACXC,SAAU,eACVC,UAAW,GACXC,SAAU,MFLAJ,EAAA,MAAa,KACvB,kDACA,uCACA,kCACA,gDACA,8CACA,8BACA,qDAGUD,EAAA,MAAa,KACvB,8CACA,mDACA,8CAGF,SAAYF,GACV,kEACA,8CACA,0CACA,gDACA,8CACA,uCACA,sDACA,wDACA,6DACD,CAVD,CAAYA,IAAAA,EAAa,KAYzB,SAAYC,GACV,mDACD,CAFD,CAAYA,IAAAA,EAAa,KAMlB,MAAM,UAAuBO,MACzBC,QAETC,UAEAC,YAAYF,EAAiBC,GAC3BE,MAAMH,GACNI,KAAKJ,QAAUA,EACfI,KAAKH,UAAYA,CACnB,CAEAI,4BAA4BC,EAAQC,GAClC,OAAOD,aAAa,GAAkBA,EAAEL,YAAcM,CACxD,EG1CkB,IAAI,IAAJ,CAAO,GAApB,MAEM,EAAM,IAAI,IAAJ,CAAO,GAEbC,EAAM,IAAI,IAAJ,CAAO,GCI1B,IAAY,ECPAC,EAKA,ECLA,EDKAC,EDEAC,EEPAC,ECoBA,ECgDA,EAAAC,EL/DQL,EAAIM,IAAI,IAAI,IAAJ,CAAO,MAEZN,EAAIM,IAAI,IAAI,IAAJ,CAAO,KAAKC,IAAI,GAEvBP,EAAIM,IAAI,IAAI,IAAJ,CAAO,MAAMC,IAAI,GMVpC,IAAI,IAAJ,CAAO,KACR,IAAI,IAAJ,CAAO,IACL,IAAI,IAAJ,CAAO,MACT,IAAI,IAAJ,CAAO,KLKPJ,EAAA,MAAa,KACvB,UACA,YCTF,SAAYF,GACV,iCACA,kCACD,CAHD,CAAYA,IAAAA,EAAe,MAKfC,EAAA,MAAc,KACxB,6BACA,yBACA,gCCRUE,EAAA,MAAS,KACnB,iBACA,kBACA,wBACA,kCACA,wBACA,2BCcF,SAAYF,GACV,oBACA,kBACA,uBACD,CAJD,CAAY,MAAc,MCgDdG,EAAA,MAA0B,KACpC,oBACA,cACA,kBACA,gBACA,kBACA,sBEjFmCvB,QAAQ,uBCARA,QAAQ,Y","sources":["webpack://@cetusprotocol/cetus-sui-clmm-sdk/webpack/bootstrap","webpack://@cetusprotocol/cetus-sui-clmm-sdk/webpack/runtime/compat get default export","webpack://@cetusprotocol/cetus-sui-clmm-sdk/webpack/runtime/define property getters","webpack://@cetusprotocol/cetus-sui-clmm-sdk/webpack/runtime/hasOwnProperty shorthand","webpack://@cetusprotocol/cetus-sui-clmm-sdk/external commonjs \"@mysten/sui.js\"","webpack://@cetusprotocol/cetus-sui-clmm-sdk/external commonjs \"bn.js\"","webpack://@cetusprotocol/cetus-sui-clmm-sdk/external commonjs \"@mysten/bcs\"","webpack://@cetusprotocol/cetus-sui-clmm-sdk/external commonjs \"decimal.js\"","webpack://@cetusprotocol/cetus-sui-clmm-sdk/./src/errors/errors.ts","webpack://@cetusprotocol/cetus-sui-clmm-sdk/./src/types/constants.ts","webpack://@cetusprotocol/cetus-sui-clmm-sdk/./src/utils/decimal.ts","webpack://@cetusprotocol/cetus-sui-clmm-sdk/./src/math/utils.ts","webpack://@cetusprotocol/cetus-sui-clmm-sdk/./src/types/liquidity.ts","webpack://@cetusprotocol/cetus-sui-clmm-sdk/./src/math/position.ts","webpack://@cetusprotocol/cetus-sui-clmm-sdk/./src/math/SplitSwap.ts","webpack://@cetusprotocol/cetus-sui-clmm-sdk/./src/modules/resourcesModule.ts","webpack://@cetusprotocol/cetus-sui-clmm-sdk/./src/types/luanchpa_type.ts","webpack://@cetusprotocol/cetus-sui-clmm-sdk/./src/math/apr.ts","webpack://@cetusprotocol/cetus-sui-clmm-sdk/external commonjs \"@syntsugar/cc-graph\"","webpack://@cetusprotocol/cetus-sui-clmm-sdk/external commonjs \"js-base64\""],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@mysten/sui.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"bn.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@mysten/bcs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"decimal.js\");","/* eslint-disable no-shadow */\nexport enum MathErrorCode {\n  IntegerDowncastOverflow = `IntegerDowncastOverflow`,\n  MulOverflow = `MultiplicationOverflow`,\n  MulDivOverflow = `MulDivOverflow`,\n  MulShiftRightOverflow = `MulShiftRightOverflow`,\n  MulShiftLeftOverflow = `MulShiftLeftOverflow`,\n  DivideByZero = `DivideByZero`,\n  UnsignedIntegerOverflow = `UnsignedIntegerOverflow`,\n}\n\nexport enum CoinErrorCode {\n  CoinAmountMaxExceeded = `CoinAmountMaxExceeded`,\n  CoinAmountMinSubceeded = `CoinAmountMinSubceeded `,\n  SqrtPriceOutOfBounds = `SqrtPriceOutOfBounds`,\n}\n\nexport enum SwapErrorCode {\n  InvalidSqrtPriceLimitDirection = `InvalidSqrtPriceLimitDirection`,\n  SqrtPriceOutOfBounds = `SqrtPriceOutOfBounds`,\n  ZeroTradableAmount = `ZeroTradableAmount`,\n  AmountOutBelowMinimum = `AmountOutBelowMinimum`,\n  AmountInAboveMaximum = `AmountInAboveMaximum`,\n  NextTickNotFound = `NextTickNoutFound`,\n  TickArraySequenceInvalid = `TickArraySequenceInvalid`,\n  TickArrayCrossingAboveMax = `TickArrayCrossingAboveMax`,\n  TickArrayIndexNotInitialized = `TickArrayIndexNotInitialized`,\n}\n\nexport enum PoolErrorCode {\n  InvalidCoinTypeSequence = `InvalidCoinTypeSequence`,\n}\n\nexport type ClmmpoolsErrorCode = MathErrorCode | SwapErrorCode | CoinErrorCode | PoolErrorCode\n\nexport class ClmmpoolsError extends Error {\n  override message: string\n\n  errorCode?: ClmmpoolsErrorCode\n\n  constructor(message: string, errorCode?: ClmmpoolsErrorCode) {\n    super(message)\n    this.message = message\n    this.errorCode = errorCode\n  }\n\n  static isClmmpoolsErrorCode(e: any, code: ClmmpoolsErrorCode): boolean {\n    return e instanceof ClmmpoolsError && e.errorCode === code\n  }\n}\n","import BN from 'bn.js'\n\n/**\n * The maximum tick index supported by the clmmpool program.\n * @category Constants\n */\nexport const MAX_TICK_INDEX = 443636\n\n/**\n * The minimum tick index supported by the clmmpool program.\n * @category Constants\n */\nexport const MIN_TICK_INDEX = -443636\n\n/**\n * The maximum sqrt-price supported by the clmmpool program.\n * @category Constants\n */\nexport const MAX_SQRT_PRICE = '79226673515401279992447579055'\n\n/**\n * The number of initialized ticks that a tick-array account can hold.\n * @category Constants\n */\nexport const TICK_ARRAY_SIZE = 64\n\n/**\n * The minimum sqrt-price supported by the clmmpool program.\n * @category Constants\n */\nexport const MIN_SQRT_PRICE = '4295048016'\n\n/**\n * The denominator which the fee rate is divided on.\n * @category Constants\n */\nexport const FEE_RATE_DENOMINATOR = new BN(1_000_000)\n","import Decimal from 'decimal.js'\n\nDecimal.config({\n  precision: 64,\n  rounding: Decimal.ROUND_DOWN,\n  toExpNeg: -64,\n  toExpPos: 64,\n})\n\nexport default Decimal\n","import BN from 'bn.js'\nimport Decimal from '../utils/decimal'\n\n// eslint-disable-next-line import/no-unresolved\nimport { ClmmpoolsError, MathErrorCode } from '../errors/errors'\n\nexport const ZERO = new BN(0)\n\nexport const ONE = new BN(1)\n\nexport const TWO = new BN(2)\n\nexport const U128 = TWO.pow(new BN(128))\n\nexport const U64_MAX = TWO.pow(new BN(64)).sub(ONE)\n\nexport const U128_MAX = TWO.pow(new BN(128)).sub(ONE)\n\n/**\n * @category MathUtil\n */\nexport class MathUtil {\n  static toX64_BN(num: BN): BN {\n    return num.mul(new BN(2).pow(new BN(64)))\n  }\n\n  static toX64_Decimal(num: Decimal): Decimal {\n    return num.mul(Decimal.pow(2, 64))\n  }\n\n  static toX64(num: Decimal): BN {\n    return new BN(num.mul(Decimal.pow(2, 64)).floor().toFixed())\n  }\n\n  static fromX64(num: BN): Decimal {\n    return new Decimal(num.toString()).mul(Decimal.pow(2, -64))\n  }\n\n  static fromX64_Decimal(num: Decimal): Decimal {\n    return num.mul(Decimal.pow(2, -64))\n  }\n\n  static fromX64_BN(num: BN): BN {\n    return num.div(new BN(2).pow(new BN(64)))\n  }\n\n  static shiftRightRoundUp(n: BN): BN {\n    let result = n.shrn(64)\n\n    if (n.mod(U64_MAX).gt(ZERO)) {\n      result = result.add(ONE)\n    }\n\n    return result\n  }\n\n  static divRoundUp(n0: BN, n1: BN): BN {\n    const hasRemainder = !n0.mod(n1).eq(ZERO)\n    if (hasRemainder) {\n      return n0.div(n1).add(new BN(1))\n    }\n    return n0.div(n1)\n  }\n\n  static subUnderflowU128(n0: BN, n1: BN): BN {\n    if (n0.lt(n1)) {\n      return n0.sub(n1).add(U128_MAX)\n    }\n\n    return n0.sub(n1)\n  }\n\n  static checkUnsignedSub(n0: BN, n1: BN): BN {\n    const n = n0.sub(n1)\n    if (n.isNeg()) {\n      throw new ClmmpoolsError('Unsigned integer sub overflow', MathErrorCode.UnsignedIntegerOverflow)\n    }\n    return n\n  }\n\n  static checkMul(n0: BN, n1: BN, limit: number): BN {\n    const n = n0.mul(n1)\n    if (this.isOverflow(n, limit)) {\n      throw new ClmmpoolsError('Multiplication overflow', MathErrorCode.MulOverflow)\n    }\n    return n\n  }\n\n  static checkMulDivFloor(n0: BN, n1: BN, denom: BN, limit: number): BN {\n    if (denom.eq(ZERO)) {\n      throw new ClmmpoolsError('Devide by zero', MathErrorCode.DivideByZero)\n    }\n    const n = n0.mul(n1).div(denom)\n    if (this.isOverflow(n, limit)) {\n      throw new ClmmpoolsError('Multiplication div overflow', MathErrorCode.MulDivOverflow)\n    }\n    return n\n  }\n\n  static checkMulDivCeil(n0: BN, n1: BN, denom: BN, limit: number): BN {\n    if (denom.eq(ZERO)) {\n      throw new ClmmpoolsError('Devide by zero', MathErrorCode.DivideByZero)\n    }\n    const n = n0.mul(n1).add(denom.sub(ONE)).div(denom)\n    if (this.isOverflow(n, limit)) {\n      throw new ClmmpoolsError('Multiplication div overflow', MathErrorCode.MulDivOverflow)\n    }\n    return n\n  }\n\n  static checkMulDivRound(n0: BN, n1: BN, denom: BN, limit: number): BN {\n    if (denom.eq(ZERO)) {\n      throw new ClmmpoolsError('Devide by zero', MathErrorCode.DivideByZero)\n    }\n    const n = n0.mul(n1.add(denom.shrn(1))).div(denom)\n    if (this.isOverflow(n, limit)) {\n      throw new ClmmpoolsError('Multiplication div overflow', MathErrorCode.MulDivOverflow)\n    }\n    return n\n  }\n\n  static checkMulShiftRight(n0: BN, n1: BN, shift: number, limit: number): BN {\n    const n = n0.mul(n1).div(new BN(2).pow(new BN(shift)))\n    // const n = n0.mul(n1).shrn(shift)\n    if (this.isOverflow(n, limit)) {\n      throw new ClmmpoolsError('Multiplication shift right overflow', MathErrorCode.MulShiftRightOverflow)\n    }\n    return n\n  }\n\n  static checkMulShiftRight64RoundUpIf(n0: BN, n1: BN, limit: number, roundUp: boolean): BN {\n    const p = n0.mul(n1)\n    const shoudRoundUp = roundUp && p.and(U64_MAX).gt(ZERO)\n    const result = shoudRoundUp ? p.shrn(64).add(ONE) : p.shrn(64)\n    if (this.isOverflow(result, limit)) {\n      throw new ClmmpoolsError('Multiplication shift right overflow', MathErrorCode.MulShiftRightOverflow)\n    }\n    return result\n  }\n\n  static checkMulShiftLeft(n0: BN, n1: BN, shift: number, limit: number): BN {\n    const n = n0.mul(n1).shln(shift)\n    if (this.isOverflow(n, limit)) {\n      throw new ClmmpoolsError('Multiplication shift left overflow', MathErrorCode.MulShiftLeftOverflow)\n    }\n    return n\n  }\n\n  static checkDivRoundUpIf(n0: BN, n1: BN, roundUp: boolean): BN {\n    if (n1.eq(ZERO)) {\n      throw new ClmmpoolsError('Devide by zero', MathErrorCode.DivideByZero)\n    }\n    if (roundUp) {\n      return this.divRoundUp(n0, n1)\n    }\n    return n0.div(n1)\n  }\n\n  static isOverflow(n: BN, bit: number): boolean {\n    return n.gte(TWO.pow(new BN(bit)))\n  }\n}\n","import BN from 'bn.js'\n\nexport type DecreaseLiquidityInput = {\n  tokenMinA: BN\n  tokenMinB: BN\n  liquidityAmount: BN\n}\n\nexport type IncreaseLiquidityInput = {\n  tokenMaxA: BN\n  tokenMaxB: BN\n  liquidityAmount: BN\n}\n\nexport enum SwapDirection {\n  A2B = 'a2b',\n  B2A = 'b2a',\n}\n","import BN from 'bn.js'\n\nimport { SwapDirection } from '../types/liquidity'\nimport { CoinAmounts } from './clmm'\nimport { Percentage } from './percentage'\nimport { MathUtil } from './utils'\n\nexport enum AmountSpecified {\n  Input = 'Specified input amount',\n  Output = 'Specified output amount',\n}\n\nexport enum PositionStatus {\n  BelowRange,\n  InRange,\n  AboveRange,\n}\n\nexport class PositionUtil {\n  static getPositionStatus(currentTickIndex: number, lowerTickIndex: number, upperTickIndex: number): PositionStatus {\n    if (currentTickIndex < lowerTickIndex) {\n      return PositionStatus.BelowRange\n    }\n    if (currentTickIndex < upperTickIndex) {\n      return PositionStatus.InRange\n    }\n    return PositionStatus.AboveRange\n  }\n}\n\n/**\n * Order sqrt price.\n * @param liquidity - liqudity.\n * @param sqrtPrice0X64 - Current sqrt price of coin 0.\n * @param sqrtPrice1X64 - Current sqrt price of coin 1.\n *\n * @returns\n */\nfunction orderSqrtPrice(sqrtPrice0X64: BN, sqrtPrice1X64: BN): [BN, BN] {\n  if (sqrtPrice0X64.lt(sqrtPrice1X64)) {\n    return [sqrtPrice0X64, sqrtPrice1X64]\n  }\n  return [sqrtPrice1X64, sqrtPrice0X64]\n}\n\n/**\n * Get token A from liquidity.\n * @param liquidity - liquidity.\n * @param sqrtPrice0X64 - Current sqrt price of coin 0.\n * @param sqrtPrice1X64 - Current sqrt price of coin 1.\n * @param roundUp - If round up.\n *\n * @returns\n */\nexport function getCoinAFromLiquidity(liquidity: BN, sqrtPrice0X64: BN, sqrtPrice1X64: BN, roundUp: boolean) {\n  const [sqrtPriceLowerX64, sqrtPriceUpperX64] = orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64)\n\n  const numerator = liquidity.mul(sqrtPriceUpperX64.sub(sqrtPriceLowerX64)).shln(64)\n  const denominator = sqrtPriceUpperX64.mul(sqrtPriceLowerX64)\n  if (roundUp) {\n    return MathUtil.divRoundUp(numerator, denominator)\n  }\n  return numerator.div(denominator)\n}\n\n/**\n * Get token B from liquidity.\n * @param liquidity - liqudity.\n * @param sqrtPrice0X64 - Current sqrt price of token 0.\n * @param sqrtPrice1X64 - Current sqrt price of token 1.\n * @param roundUp - If round up.\n *\n * @returns\n */\nexport function getCoinBFromLiquidity(liquidity: BN, sqrtPrice0X64: BN, sqrtPrice1X64: BN, roundUp: boolean) {\n  const [sqrtPriceLowerX64, sqrtPriceUpperX64] = orderSqrtPrice(sqrtPrice0X64, sqrtPrice1X64)\n\n  const result = liquidity.mul(sqrtPriceUpperX64.sub(sqrtPriceLowerX64))\n  if (roundUp) {\n    return MathUtil.shiftRightRoundUp(result)\n  }\n  return result.shrn(64)\n}\n\n/**\n * Get liquidity from token A.\n *\n * @param amount - The amount of token A.\n * @param sqrtPriceLowerX64 - The lower sqrt price.\n * @param sqrtPriceUpperX64 - The upper sqrt price.\n * @param roundUp - If round up.\n * @returns liquidity.\n */\nexport function getLiquidityFromCoinA(amount: BN, sqrtPriceLowerX64: BN, sqrtPriceUpperX64: BN, roundUp: boolean) {\n  const result = amount.mul(sqrtPriceLowerX64).mul(sqrtPriceUpperX64).div(sqrtPriceUpperX64.sub(sqrtPriceLowerX64))\n  if (roundUp) {\n    return MathUtil.shiftRightRoundUp(result)\n  }\n  return result.shrn(64)\n}\n\n/**\n * Get liquidity from token B.\n * @param amount - The amount of token B.\n * @param sqrtPriceLowerX64 - The lower sqrt price.\n * @param sqrtPriceUpperX64 - The upper sqrt price.\n * @param roundUp - If round up.\n *\n * @returns liquidity.\n */\nexport function getLiquidityFromCoinB(amount: BN, sqrtPriceLowerX64: BN, sqrtPriceUpperX64: BN, roundUp: boolean) {\n  const numerator = amount.shln(64)\n  const denominator = sqrtPriceUpperX64.sub(sqrtPriceLowerX64)\n  if (roundUp) {\n    return MathUtil.divRoundUp(numerator, denominator)\n  }\n  return numerator.div(denominator)\n}\n\n/**\n * Get amount of fixed delta.\n * @param currentSqrtPriceX64 - Current sqrt price.\n * @param targetSqrtPriceX64 - Target sqrt price.\n * @param liquidity - liqudity.\n * @param amountSpecified - The amount specified in the swap.\n * @param swapDirection - The swap direction.\n *\n * @returns\n */\nexport function getAmountFixedDelta(\n  currentSqrtPriceX64: BN,\n  targetSqrtPriceX64: BN,\n  liquidity: BN,\n  amountSpecified: AmountSpecified,\n  swapDirection: SwapDirection\n) {\n  if ((amountSpecified === AmountSpecified.Input) === (swapDirection === SwapDirection.A2B)) {\n    return getCoinAFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified === AmountSpecified.Input)\n  }\n  return getCoinBFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified === AmountSpecified.Input)\n}\n\n/**\n * Get amount of unfixed delta.\n * @param currentSqrtPriceX64 - Current sqrt price.\n * @param targetSqrtPriceX64 - Target sqrt price.\n * @param liquidity - liqudity.\n * @param amountSpecified - The amount specified in the swap.\n * @param swapDirection - The swap direction.\n *\n * @returns\n */\nexport function getAmountUnfixedDelta(\n  currentSqrtPriceX64: BN,\n  targetSqrtPriceX64: BN,\n  liquidity: BN,\n  amountSpecified: AmountSpecified,\n  swapDirection: SwapDirection\n) {\n  if ((amountSpecified === AmountSpecified.Input) === (swapDirection === SwapDirection.A2B)) {\n    return getCoinBFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified === AmountSpecified.Output)\n  }\n  return getCoinAFromLiquidity(liquidity, currentSqrtPriceX64, targetSqrtPriceX64, amountSpecified === AmountSpecified.Output)\n}\n\nexport function adjustForSlippage(n: BN, { numerator, denominator }: Percentage, adjustUp: boolean): BN {\n  if (adjustUp) {\n    return n.mul(denominator.add(numerator)).div(denominator)\n  }\n  return n.mul(denominator).div(denominator.add(numerator))\n}\n\nexport function adjustForCoinSlippage(tokenAmount: CoinAmounts, slippage: Percentage, adjustUp: boolean) {\n  return {\n    tokenMaxA: adjustForSlippage(tokenAmount.coinA, slippage, adjustUp),\n    tokenMaxB: adjustForSlippage(tokenAmount.coinB, slippage, adjustUp),\n  }\n}\n","import BN from 'bn.js'\nimport { ClmmpoolData, TickData, transClmmpoolDataWithoutTicks } from '../types/clmmpool'\nimport { Pool } from '../modules/resourcesModule'\nimport { computeSwapStep, SwapStepResult } from './clmm'\nimport { SwapUtils } from './swap'\nimport { ZERO } from './utils'\n\nexport enum SplitUnit {\n  FIVE = 5,\n  TEN = 10,\n  TWENTY = 20,\n  TWENTY_FIVE = 25,\n  FIVETY = 50,\n  HUNDRED = 100,\n}\n\nexport function createSplitArray(minSplitUnit: SplitUnit): number[] {\n  let unit\n  switch (minSplitUnit) {\n    case SplitUnit.FIVE:\n      unit = 5\n      break\n    case SplitUnit.TEN:\n      unit = 10\n      break\n    case SplitUnit.TWENTY:\n      unit = 20\n      break\n    case SplitUnit.TWENTY_FIVE:\n      unit = 25\n      break\n    case SplitUnit.FIVETY:\n      unit = 50\n      break\n    case SplitUnit.HUNDRED:\n      unit = 100\n      break\n    default:\n      unit = 1\n  }\n  const length = 100 / unit + 1\n  const splitArray = new Array<number>(length)\n  for (let i = 0; i < length; i += 1) {\n    splitArray[i] = i * unit\n  }\n  return splitArray\n}\n\nexport function createSplitAmountArray(amount: BN, minSplitUnit: SplitUnit): BN[] {\n  const splitArray = createSplitArray(minSplitUnit)\n  const splitAmountArray = new Array<BN>(splitArray.length)\n\n  for (let i = 0; i < splitArray.length; i += 1) {\n    splitAmountArray[i] = amount.muln(splitArray[i]).divn(100)\n  }\n\n  return splitAmountArray\n}\n\nexport type SplitSwapResult = {\n  amountInArray: BN[]\n  amountOutArray: BN[]\n  feeAmountArray: BN[]\n  nextSqrtPriceArray: BN[]\n  isExceed: boolean[]\n}\n\nfunction updateSplitSwapResult(\n  maxIndex: number,\n  currentIndex: number,\n  splitSwapResult: SplitSwapResult,\n  stepResult: SwapStepResult\n): SplitSwapResult {\n  for (let index = currentIndex; index < maxIndex; index += 1) {\n    splitSwapResult.amountInArray[index] = splitSwapResult.amountInArray[index].add(stepResult.amountIn)\n    splitSwapResult.amountOutArray[index] = splitSwapResult.amountOutArray[index].add(stepResult.amountOut)\n    splitSwapResult.feeAmountArray[index] = splitSwapResult.feeAmountArray[index].add(stepResult.feeAmount)\n  }\n  return splitSwapResult\n}\n\nfunction computeSplitSwap(\n  a2b: boolean,\n  byAmountIn: boolean,\n  amounts: BN[],\n  poolData: ClmmpoolData,\n  swapTicks: TickData[]\n): SplitSwapResult {\n  let currentLiquidity = new BN(poolData.liquidity)\n  let { currentSqrtPrice } = poolData\n\n  let splitSwapResult: SplitSwapResult = {\n    amountInArray: [],\n    amountOutArray: [],\n    feeAmountArray: [],\n    nextSqrtPriceArray: [],\n    isExceed: [],\n  }\n\n  amounts.forEach(() => {\n    splitSwapResult.amountInArray.push(ZERO)\n    splitSwapResult.amountOutArray.push(ZERO)\n    splitSwapResult.feeAmountArray.push(ZERO)\n    splitSwapResult.nextSqrtPriceArray.push(ZERO)\n  })\n\n  let targetSqrtPrice\n  let signedLiquidityChange\n  const sqrtPriceLimit = SwapUtils.getDefaultSqrtPriceLimit(a2b)\n\n  const maxIndex = amounts.length\n  let remainerAmount = amounts[1]\n  let currentIndex = 1\n\n  let ticks\n  if (a2b) {\n    ticks = swapTicks.sort((a, b) => {\n      return b.index - a.index\n    })\n  } else {\n    ticks = swapTicks.sort((a, b) => {\n      return a.index - b.index\n    })\n  }\n\n  for (const tick of ticks) {\n    if (a2b) {\n      if (poolData.currentTickIndex < tick.index) {\n        continue\n      }\n    } else if (poolData.currentTickIndex > tick.index) {\n      continue\n    }\n    if (tick === null) {\n      continue\n    }\n    if ((a2b && sqrtPriceLimit.gt(tick.sqrtPrice)) || (!a2b && sqrtPriceLimit.lt(tick.sqrtPrice))) {\n      targetSqrtPrice = sqrtPriceLimit\n    } else {\n      targetSqrtPrice = tick.sqrtPrice\n    }\n\n    let tempStepResult: SwapStepResult = {\n      amountIn: ZERO,\n      amountOut: ZERO,\n      nextSqrtPrice: ZERO,\n      feeAmount: ZERO,\n    }\n\n    const tempSqrtPrice = currentSqrtPrice\n    const tempLiquidity = currentLiquidity\n    let tempRemainerAmount = remainerAmount\n    let currentTempIndex = currentIndex\n\n    for (let i = currentIndex; i < maxIndex; i += 1) {\n      const stepResult = computeSwapStep(\n        currentSqrtPrice,\n        targetSqrtPrice,\n        currentLiquidity,\n        remainerAmount,\n        new BN(poolData.feeRate),\n        byAmountIn\n      )\n      tempStepResult = stepResult\n\n      if (!stepResult.amountIn.eq(ZERO)) {\n        remainerAmount = byAmountIn\n          ? remainerAmount.sub(stepResult.amountIn.add(stepResult.feeAmount))\n          : remainerAmount.sub(stepResult.amountOut)\n      }\n\n      // splitSwapResult = updateSplitSwapResult(maxIndex, currentIndex, splitSwapResult, stepResult)\n      if (remainerAmount.eq(ZERO)) {\n        splitSwapResult.amountInArray[i] = splitSwapResult.amountInArray[i].add(stepResult.amountIn)\n        splitSwapResult.amountOutArray[i] = splitSwapResult.amountOutArray[i].add(stepResult.amountOut)\n        splitSwapResult.feeAmountArray[i] = splitSwapResult.feeAmountArray[i].add(stepResult.feeAmount)\n\n        // When current index remainerAmount run out, we need to update the swapResult of current index amountIn\n        if (stepResult.nextSqrtPrice.eq(tick.sqrtPrice)) {\n          signedLiquidityChange = a2b ? tick.liquidityNet.mul(new BN(-1)) : tick.liquidityNet\n          currentLiquidity = signedLiquidityChange.gt(ZERO)\n            ? currentLiquidity.add(signedLiquidityChange)\n            : currentLiquidity.sub(signedLiquidityChange.abs())\n          currentSqrtPrice = tick.sqrtPrice\n        } else {\n          currentSqrtPrice = stepResult.nextSqrtPrice\n        }\n        splitSwapResult.amountInArray[i] = splitSwapResult.amountInArray[i].add(splitSwapResult.feeAmountArray[i])\n        splitSwapResult.nextSqrtPriceArray[i] = currentSqrtPrice\n        currentLiquidity = tempLiquidity\n        currentSqrtPrice = tempSqrtPrice\n        // remainerAmount = tempRemainerAmount.add(amounts[1].muln(i - currentTempIndex + 1))\n        if (i !== maxIndex - 1) {\n          remainerAmount = tempRemainerAmount.add(amounts[i + 1].sub(amounts[currentTempIndex]))\n        }\n        currentIndex += 1\n      } else {\n        splitSwapResult = updateSplitSwapResult(maxIndex, i, splitSwapResult, stepResult)\n        tempRemainerAmount = remainerAmount\n        currentTempIndex = currentIndex\n        break\n      }\n    }\n\n    if (currentIndex === maxIndex) {\n      break\n    }\n\n    if (tempStepResult.nextSqrtPrice.eq(tick.sqrtPrice)) {\n      signedLiquidityChange = a2b ? tick.liquidityNet.mul(new BN(-1)) : tick.liquidityNet\n      currentLiquidity = signedLiquidityChange.gt(ZERO)\n        ? currentLiquidity.add(signedLiquidityChange)\n        : currentLiquidity.sub(signedLiquidityChange.abs())\n      currentSqrtPrice = tick.sqrtPrice\n    } else {\n      currentSqrtPrice = tempStepResult.nextSqrtPrice\n    }\n  }\n\n  if (byAmountIn) {\n    amounts.forEach((a, i) => {\n      splitSwapResult.isExceed.push(splitSwapResult.amountInArray[i].lt(a))\n    })\n  } else {\n    amounts.forEach((a, i) => {\n      splitSwapResult.isExceed.push(splitSwapResult.amountOutArray[i].lt(a))\n    })\n  }\n\n  return splitSwapResult\n}\n\nexport class SplitSwap {\n  readonly minSplitUnit: number\n\n  amountArray: BN[]\n\n  private byAmountIn: boolean\n\n  private a2b: boolean\n\n  private clmmpool: Pool\n\n  private ticks: TickData[]\n\n  private splitSwapResult: SplitSwapResult\n\n  constructor(amount: BN, unit: SplitUnit, clmmpool: Pool, a2b: boolean, byAmountIn: boolean, tickData: TickData[]) {\n    this.minSplitUnit = unit\n    this.a2b = a2b\n    this.byAmountIn = byAmountIn\n    this.clmmpool = clmmpool\n    this.ticks = tickData\n    this.amountArray = []\n    this.createSplitSwapParams = this.createSplitSwapParams.bind(this)\n    this.createSplitSwapParams(amount, unit)\n    this.splitSwapResult = {\n      amountInArray: [],\n      amountOutArray: [],\n      feeAmountArray: [],\n      nextSqrtPriceArray: [],\n      isExceed: [],\n    }\n    this.computeSwap = this.computeSwap.bind(this)\n  }\n\n  createSplitSwapParams(amount: BN, unit: SplitUnit) {\n    const amountArray = createSplitAmountArray(amount, unit)\n    this.amountArray = amountArray\n  }\n\n  computeSwap(): SplitSwapResult {\n    const pool = transClmmpoolDataWithoutTicks(this.clmmpool)\n    this.splitSwapResult = computeSplitSwap(this.a2b, this.byAmountIn, this.amountArray, pool, this.ticks)\n    return this.splitSwapResult\n  }\n}\n","/* eslint-disable no-constant-condition */\nimport {\n  Coin,\n  getMoveObject,\n  getObjectFields,\n  getObjectPreviousTransactionDigest,\n  ObjectContentFields,\n  PaginatedCoins,\n  SuiMoveObject,\n  SuiObjectResponse,\n  SuiTransactionBlockResponse,\n  TransactionDigest,\n} from '@mysten/sui.js'\nimport { CachedContent } from '../utils/cachedContent'\nimport { buildPool, buildPosition, buildPositionReward, multiGetObjects } from '../utils/common'\nimport { SuiAddressType, SuiObjectIdType, SuiResource, NFT } from '../types/sui'\nimport { SDK } from '../sdk'\nimport { IModule } from '../interfaces/IModule'\nimport { extractStructTagFromType } from '../utils/contracts'\nimport { addHexPrefix } from '../utils/hex'\nimport { CoinAssist } from '../math/CoinAssist'\nimport { loopToGetAllQueryEvents } from '../utils'\n\nexport const cacheTime5min = 5 * 60 * 1000\nexport const cacheTime24h = 24 * 60 * 60 * 1000\nexport const intervalFaucetTime = 12 * 60 * 60 * 1000\n\nexport enum PositionStatus {\n  'Deleted' = 'Deleted',\n  'Exists' = 'Exists',\n  'NotExists' = 'NotExists',\n}\n\nexport type Position = {\n  pos_object_id: SuiObjectIdType\n  owner: SuiObjectIdType\n  pool: SuiObjectIdType\n  type: SuiAddressType\n  coin_type_a: SuiAddressType\n  coin_type_b: SuiAddressType\n  index: number\n  liquidity: string\n  tick_lower_index: number\n  tick_upper_index: number\n  position_status: PositionStatus\n} & NFT &\n  PositionReward\n\nexport type PositionReward = {\n  pos_object_id: SuiObjectIdType\n  liquidity: string\n  tick_lower_index: number\n  tick_upper_index: number\n  fee_growth_inside_a: string\n  fee_owed_a: string\n  fee_growth_inside_b: string\n  fee_owed_b: string\n  reward_amount_owed_0: string\n  reward_amount_owed_1: string\n  reward_amount_owed_2: string\n  reward_growth_inside_0: string\n  reward_growth_inside_1: string\n  reward_growth_inside_2: string\n}\n\nexport type CoinPairType = {\n  coinTypeA: SuiAddressType\n  coinTypeB: SuiAddressType\n}\n\nexport type PoolImmutables = {\n  poolAddress: string\n  tickSpacing: string\n} & CoinPairType\n\nexport type Pool = {\n  poolType: string\n  coinAmountA: number\n  coinAmountB: number\n  /// The current sqrt price\n  current_sqrt_price: number\n  /// The current tick index\n  current_tick_index: number\n  /// The global fee growth of coin a,b as Q64.64\n  fee_growth_global_b: number\n  fee_growth_global_a: number\n  /// The amounts of coin a,b owend to protocol\n  fee_protocol_coin_a: number\n  fee_protocol_coin_b: number\n  /// The numerator of fee rate, the denominator is 1_000_000.\n  fee_rate: number\n  /// is the pool pause\n  is_pause: boolean\n  /// The liquidity of current tick index\n  liquidity: number\n  /// The pool index\n  index: number\n  positions_handle: string\n  rewarder_infos: Array<Rewarder>\n  rewarder_last_updated_time: string\n  ticks_handle: string\n  uri: string\n  name: string\n} & PoolImmutables\n\nexport type Rewarder = {\n  coinAddress: string\n  emissions_per_second: number\n  growth_global: number\n  emissionsEveryDay: number\n}\n\nexport type InitEvent = {\n  pools_id: SuiObjectIdType\n  global_config_id: SuiObjectIdType\n  global_vault_id: SuiObjectIdType\n}\n\nexport type CreatePartnerEvent = {\n  name: string\n  recipient: SuiAddressType\n  partner_id: SuiObjectIdType\n  partner_cap_id: SuiObjectIdType\n  fee_rate: string\n  start_epoch: string\n  end_epoch: string\n}\n\nexport type FaucetEvent = {\n  id: string\n  time: number\n}\n\nexport type CoinAsset = {\n  coinAddress: SuiAddressType\n  coinObjectId: SuiObjectIdType\n  balance: bigint\n}\n\nexport type WarpSuiObject = {\n  coinAddress: SuiAddressType\n  balance: number\n} & SuiMoveObject\n\nexport type FaucetCoin = {\n  transactionModule: string\n  suplyID: SuiObjectIdType\n  decimals: number\n} & ObjectContentFields\n\nfunction getFutureTime(interval: number) {\n  return Date.parse(new Date().toString()) + interval\n}\n\nexport class ResourcesModule implements IModule {\n  protected _sdk: SDK\n\n  private readonly _cache: Record<string, CachedContent> = {}\n\n  constructor(sdk: SDK) {\n    this._sdk = sdk\n  }\n\n  get sdk() {\n    return this._sdk\n  }\n\n  async getSuiTransactionResponse(digest: TransactionDigest, forceRefresh = false): Promise<SuiTransactionBlockResponse | null> {\n    const cacheKey = `${digest}_getSuiTransactionResponse`\n    const cacheData = this._cache[cacheKey]\n\n    if (cacheData !== undefined && cacheData.getCacheData() && !forceRefresh) {\n      return cacheData.value as SuiTransactionBlockResponse\n    }\n    let objects\n    try {\n      objects = (await this._sdk.fullClient.getTransactionBlock({\n        digest,\n        options: {\n          showEvents: true,\n          showEffects: true,\n          showBalanceChanges: true,\n          showInput: true,\n          showObjectChanges: true,\n        },\n      })) as SuiTransactionBlockResponse\n    } catch (error) {\n      objects = (await this._sdk.fullClient.getTransactionBlock({\n        digest,\n        options: {\n          showEvents: true,\n          showEffects: true,\n        },\n      })) as SuiTransactionBlockResponse\n    }\n\n    this.updateCache(cacheKey, objects, cacheTime24h)\n    return objects\n  }\n\n  async getFaucetEvent(packageObjectId: SuiObjectIdType, walletAddress: SuiAddressType, forceRefresh = true): Promise<FaucetEvent | null> {\n    const cacheKey = `${packageObjectId}_${walletAddress}_getFaucetEvent`\n    const cacheData = this._cache[cacheKey]\n\n    if (cacheData !== undefined && cacheData.getCacheData() && !forceRefresh) {\n      return cacheData.value as FaucetEvent\n    }\n    const objects = (\n      await loopToGetAllQueryEvents(this._sdk, {\n        query: { MoveEventType: `${packageObjectId}::faucet::FaucetEvent` },\n      })\n    )?.data\n    let findFaucetEvent: FaucetEvent = {\n      id: '',\n      time: 0,\n    }\n    objects.forEach((eventObject: any) => {\n      if (addHexPrefix(walletAddress) === eventObject.sender) {\n        const fields = eventObject.parsedJson\n        if (fields) {\n          const faucetEvent = {\n            id: fields.id,\n            time: Number(fields.time),\n          }\n          const findTime = findFaucetEvent.time\n          if (findTime > 0) {\n            if (faucetEvent.time > findTime) {\n              findFaucetEvent = faucetEvent\n            }\n          } else {\n            findFaucetEvent = faucetEvent\n          }\n        }\n      }\n    })\n    if (findFaucetEvent.time > 0) {\n      this.updateCache(cacheKey, findFaucetEvent, cacheTime24h)\n      return findFaucetEvent\n    }\n    return null\n  }\n\n  async getInitEvent(forceRefresh = false): Promise<InitEvent> {\n    const packageObjectId = this._sdk.sdkOptions.clmm.clmm_display\n    const cacheKey = `${packageObjectId}_getInitEvent`\n    const cacheData = this._cache[cacheKey]\n\n    if (cacheData !== undefined && cacheData.getCacheData() && !forceRefresh) {\n      return cacheData.value as InitEvent\n    }\n    const packageObject = await this._sdk.fullClient.getObject({\n      id: packageObjectId,\n      options: { showPreviousTransaction: true },\n    })\n\n    const previousTx = getObjectPreviousTransactionDigest(packageObject) as string\n\n    const objects = (\n      await loopToGetAllQueryEvents(this._sdk, {\n        query: { Transaction: previousTx },\n      })\n    )?.data\n\n    // console.log('objects: ', objects)\n\n    const initEvent: InitEvent = {\n      pools_id: '',\n      global_config_id: '',\n      global_vault_id: '',\n    }\n\n    if (objects.length > 0) {\n      objects.forEach((item: any) => {\n        const fields = item.parsedJson as any\n        if (item.type) {\n          switch (extractStructTagFromType(item.type).full_address) {\n            case `${packageObjectId}::config::InitConfigEvent`:\n              initEvent.global_config_id = fields.global_config_id\n              break\n            case `${packageObjectId}::factory::InitFactoryEvent`:\n              initEvent.pools_id = fields.pools_id\n              break\n            case `${packageObjectId}::rewarder::RewarderInitEvent`:\n              initEvent.global_vault_id = fields.global_vault_id\n              break\n            default:\n              break\n          }\n        }\n      })\n      this.updateCache(cacheKey, initEvent, cacheTime24h)\n      return initEvent\n    }\n\n    return initEvent\n  }\n\n  async getCreatePartnerEvent(forceRefresh = false): Promise<CreatePartnerEvent[]> {\n    const packageObjectId = this._sdk.sdkOptions.clmm.clmm_display\n    const cacheKey = `${packageObjectId}_getInitEvent`\n    const cacheData = this._cache[cacheKey]\n\n    if (cacheData !== undefined && cacheData.getCacheData() && !forceRefresh) {\n      return cacheData.value as CreatePartnerEvent[]\n    }\n    const objects = (\n      await loopToGetAllQueryEvents(this._sdk, {\n        query: { MoveEventType: `${packageObjectId}::partner::CreatePartnerEvent` },\n      })\n    )?.data\n    const events: CreatePartnerEvent[] = []\n\n    if (objects.length > 0) {\n      objects.forEach((item: any) => {\n        events.push(item.parsedJson as CreatePartnerEvent)\n      })\n      this.updateCache(cacheKey, events, cacheTime24h)\n    }\n\n    return events\n  }\n\n  async getPoolImmutables(assignPools: string[] = [], offset = 0, limit = 100, forceRefresh = false): Promise<PoolImmutables[]> {\n    const clmmIntegrate = this._sdk.sdkOptions.clmm.clmm_display\n    const cacheKey = `${clmmIntegrate}_getInitPoolEvent`\n    const cacheData = this._cache[cacheKey]\n\n    const allPools: PoolImmutables[] = []\n    const filterPools: PoolImmutables[] = []\n\n    if (cacheData !== undefined && cacheData.getCacheData() && !forceRefresh) {\n      allPools.push(...(cacheData.value as PoolImmutables[]))\n    }\n\n    if (allPools.length === 0) {\n      try {\n        const objects = await loopToGetAllQueryEvents(this._sdk, {\n          query: { MoveEventType: `${clmmIntegrate}::factory::CreatePoolEvent` },\n        })\n\n        // console.log('objects: ', objects)\n\n        objects.data.forEach((object: any) => {\n          const fields = object.parsedJson\n          if (fields) {\n            allPools.push({\n              poolAddress: fields.pool_id,\n              tickSpacing: fields.tick_spacing,\n              coinTypeA: extractStructTagFromType(fields.coin_type_a).full_address,\n              coinTypeB: extractStructTagFromType(fields.coin_type_b).full_address,\n            })\n          }\n        })\n        this.updateCache(cacheKey, allPools, cacheTime24h)\n      } catch (error) {\n        console.log('getPoolImmutables', error)\n      }\n    }\n\n    const hasassignPools = assignPools.length > 0\n\n    for (let index = 0; index < allPools.length; index += 1) {\n      const item = allPools[index]\n\n      if (hasassignPools && !assignPools.includes(item.poolAddress)) {\n        continue\n      }\n      if (!hasassignPools) {\n        const itemIndex = index\n        if (itemIndex < offset || itemIndex >= offset + limit) {\n          continue\n        }\n      }\n      filterPools.push(item)\n    }\n    return filterPools\n  }\n\n  async getPools(assignPools: string[] = [], offset = 0, limit = 100): Promise<Pool[]> {\n    // console.log(assignPools)\n    const allPool: Pool[] = []\n    let poolObjectIds: string[] = []\n\n    if (assignPools.length > 0) {\n      poolObjectIds = [...assignPools]\n    } else {\n      const poolImmutables = await this.getPoolImmutables([], offset, limit, false)\n      poolImmutables.forEach((item) => {\n        poolObjectIds.push(item.poolAddress)\n      })\n    }\n\n    const objectDataResponses: any[] = await multiGetObjects(this._sdk, poolObjectIds, {\n      showContent: true,\n      showType: true,\n    })\n\n    for (const suiObj of objectDataResponses) {\n      const pool = buildPool(suiObj)\n      allPool.push(pool)\n      const cacheKey = `${pool.poolAddress}_getPoolObject`\n      this.updateCache(cacheKey, pool, cacheTime24h)\n    }\n    return allPool\n  }\n\n  async getPool(poolObjectId: string, forceRefresh = true): Promise<Pool> {\n    const cacheKey = `${poolObjectId}_getPoolObject`\n    const cacheData = this._cache[cacheKey]\n\n    if (cacheData !== undefined && cacheData.getCacheData() && !forceRefresh) {\n      return cacheData.value as Pool\n    }\n    const objects = (await this._sdk.fullClient.getObject({\n      id: poolObjectId,\n      options: {\n        showType: true,\n        showContent: true,\n      },\n    })) as SuiObjectResponse\n    const pool = buildPool(objects)\n    this.updateCache(cacheKey, pool)\n    return pool\n  }\n\n  buildPositionType() {\n    const cetusClmm = this._sdk.sdkOptions.clmm.clmm_display\n    return `${cetusClmm}::position::Position`\n  }\n\n  async getPositionList(accountAddress: string, assignPoolIds: string[] = []): Promise<Position[]> {\n    const allPosition: Position[] = []\n    let cursor = null\n\n    while (true) {\n      // eslint-disable-next-line no-await-in-loop\n      const ownerRes: any = await this._sdk.fullClient.getOwnedObjects({\n        owner: accountAddress,\n        options: { showType: true, showContent: true, showDisplay: true, showOwner: true },\n        cursor,\n        // filter: { Package: cetusClmm },\n      })\n\n      const hasAssignPoolIds = assignPoolIds.length > 0\n      for (const item of ownerRes.data as any[]) {\n        const type = extractStructTagFromType(item.data.type)\n\n        if (type.full_address === this.buildPositionType()) {\n          const position = buildPosition(item)\n          const cacheKey = `${position.pos_object_id}_getPositionList`\n          this.updateCache(cacheKey, position, cacheTime24h)\n          if (hasAssignPoolIds) {\n            if (assignPoolIds.includes(position.pool)) {\n              allPosition.push(position)\n            }\n          } else {\n            allPosition.push(position)\n          }\n        }\n      }\n\n      if (ownerRes.hasNextPage) {\n        cursor = ownerRes.nextCursor\n      } else {\n        break\n      }\n    }\n\n    return allPosition\n  }\n\n  async getPosition(positionHandle: string, positionId: string): Promise<Position> {\n    let position = await this.getSipmlePosition(positionId)\n    position = await this.updatePositionRewarders(positionHandle, position)\n    return position\n  }\n\n  async getPositionById(positionId: string): Promise<Position> {\n    const position = await this.getSipmlePosition(positionId)\n    console.log('position: ', position)\n\n    const pool = await this.getPool(position.pool, false)\n    const result = await this.updatePositionRewarders(pool.positions_handle, position)\n    return result\n  }\n\n  async getSipmlePosition(positionId: string): Promise<Position> {\n    const cacheKey = `${positionId}_getPositionList`\n\n    let position = this.getSipmlePositionByCache(positionId)\n\n    if (position === undefined) {\n      const objectDataResponses = await this.sdk.fullClient.getObject({\n        id: positionId,\n        options: { showContent: true, showType: true, showDisplay: true, showOwner: true },\n      })\n      position = buildPosition(objectDataResponses)\n\n      this.updateCache(cacheKey, position, cacheTime24h)\n    }\n    return position\n  }\n\n  private getSipmlePositionByCache(positionId: string): Position | undefined {\n    const cacheKey = `${positionId}_getPositionList`\n    const cacheData = this._cache[cacheKey]\n    if (cacheData !== undefined && cacheData.getCacheData()) {\n      return cacheData.value as Position\n    }\n    return undefined\n  }\n\n  async getSipmlePositionList(positionIds: SuiObjectIdType[]): Promise<Position[]> {\n    const positionList: Position[] = []\n    const notFoundIds: SuiObjectIdType[] = []\n\n    positionIds.forEach((id) => {\n      const position = this.getSipmlePositionByCache(id)\n      if (position) {\n        positionList.push(position)\n      } else {\n        notFoundIds.push(id)\n      }\n    })\n\n    if (notFoundIds.length > 0) {\n      const objectDataResponses = await multiGetObjects(this._sdk, notFoundIds, {\n        showOwner: true,\n        showContent: true,\n        showDisplay: true,\n        showType: true,\n      })\n\n      objectDataResponses.forEach((info) => {\n        const position = buildPosition(info)\n        positionList.push(position)\n        const cacheKey = `${position.pos_object_id}_getPositionList`\n        this.updateCache(cacheKey, position, cacheTime24h)\n      })\n    }\n\n    return positionList\n  }\n\n  private async updatePositionRewarders(positionHandle: string, position: Position): Promise<Position> {\n    // const res = await sdk.fullClient.getDynamicFields({parentId: \"0x70aca04c93afb16bbe8e7cf132aaa40186e4b3e8197aa239619f662e3eb46a3a\"})\n    const res = await this._sdk.fullClient.getDynamicFieldObject({\n      parentId: positionHandle,\n      name: {\n        type: '0x2::object::ID',\n        value: position.pos_object_id,\n      },\n    })\n\n    const { fields } = (getObjectFields(res.data as any) as any).value.fields.value\n\n    const positionReward = buildPositionReward(fields)\n    return {\n      ...position,\n      ...positionReward,\n    }\n  }\n\n  async getOwnerCoinAssets(suiAddress: string, coinType?: string | null): Promise<CoinAsset[]> {\n    const allCoinAsset: CoinAsset[] = []\n    let nextCursor: string | null = null\n\n    while (true) {\n      // eslint-disable-next-line no-await-in-loop\n      const allCoinObject: PaginatedCoins = await (coinType\n        ? this._sdk.fullClient.getCoins({\n            owner: suiAddress,\n            coinType,\n            cursor: nextCursor,\n          })\n        : this._sdk.fullClient.getAllCoins({\n            owner: suiAddress,\n            cursor: nextCursor,\n          }))\n\n      // eslint-disable-next-line no-loop-func\n      allCoinObject.data.forEach((coin: any) => {\n        if (BigInt(coin.balance) > 0) {\n          allCoinAsset.push({\n            coinAddress: extractStructTagFromType(coin.coinType).source_address,\n            coinObjectId: coin.coinObjectId,\n            balance: BigInt(coin.balance),\n          })\n        }\n      })\n      nextCursor = allCoinObject.nextCursor\n\n      if (!allCoinObject.hasNextPage) {\n        break\n      }\n    }\n    return allCoinAsset\n  }\n\n  async getSuiObjectOwnedByAddress(suiAddress: string): Promise<WarpSuiObject[]> {\n    const allSuiObjects: WarpSuiObject[] = []\n    const allObjectRefs = await this._sdk.fullClient.getOwnedObjects({\n      owner: suiAddress,\n    })\n\n    const objectIDs = allObjectRefs.data.map((anObj: any) => anObj.objectId)\n    const allObjRes = await this._sdk.fullClient.multiGetObjects({\n      ids: objectIDs,\n    })\n    allObjRes.forEach((objRes) => {\n      const moveObject = getMoveObject(objRes)\n      if (moveObject) {\n        const coinAddress = CoinAssist.getCoinTypeArg(moveObject) as SuiAddressType\n        const balance = Coin.getBalance(moveObject) as unknown as number\n        const coinAsset: WarpSuiObject = {\n          coinAddress,\n          balance,\n          ...moveObject,\n        }\n        allSuiObjects.push(coinAsset)\n      }\n    })\n    return allSuiObjects\n  }\n\n  private updateCache(key: string, data: SuiResource, time = cacheTime5min) {\n    let cacheData = this._cache[key]\n    if (cacheData) {\n      cacheData.overdueTime = getFutureTime(time)\n      cacheData.value = data\n    } else {\n      cacheData = new CachedContent(data, getFutureTime(time))\n    }\n    this._cache[key] = cacheData\n  }\n}\nfunction item(item: any): any {\n  throw new Error('Function not implemented.')\n}\n","import { SuiObjectIdType, SuiAddressType } from './sui'\n\nexport const LaunchpadRouterModule = 'router'\nexport const CONST_DENOMINATOR = 1_000_000_000\n\nexport type LaunchpadCoinPairType = {\n  coin_type_sale: SuiAddressType\n  coin_type_raise: SuiAddressType\n}\n\nexport type LaunchpadInitEvent = {\n  pools_id: SuiObjectIdType\n  admin_cap_id: SuiObjectIdType\n  config_cap_id: SuiObjectIdType\n}\nexport type LaunchpadInitLockEvent = {\n  lock_manager_id: SuiObjectIdType\n}\n\nexport type LockNFTEvent = {\n  locked_time: number\n  end_lock_time: number\n  nft_type: string\n  lock_nft_id: SuiObjectIdType\n  recipient: SuiObjectIdType\n}\n\nexport type LaunchpadPoolImmutables = {\n  coin_type_sale: SuiAddressType // The pool SaleCoin type\n  coin_type_raise: SuiAddressType // The pool RaiseCoin type\n  pool_address: SuiObjectIdType\n}\n\nexport type LaunchpadPoolState = {\n  pool_type: SuiAddressType\n  is_settle: boolean /// Whether the pool has been settled\n  current_price: string\n  min_price: string\n  max_price: string\n  sale_coin_amount: string\n  raise_coin_amount: string\n  sale_total: string /// The maximum value of coins sold in the pool\n  min_purchase: string /// each user Minimum purchase amount\n  max_purchase: string /// each user max purchase amount\n  least_raise_amount: string /// each user max purchase amount\n  softcap: string\n  hardcap: string\n  liquidity_rate: number /// real rate = liquidity_rate / 100\n  activity_start_time: number /// Pool start selling time\n  activity_end_time: number\n  settle_end_time: number\n  locked_duration: number\n  activity_duration: number\n  settle_duration: number\n  is_cancel: boolean\n  white_summary: {\n    white_handle: string\n    white_hard_cap_total: string\n    white_purchase_total: string\n    size: number\n  }\n  unused_sale: string\n  harvest_raise: string /// Amount of raise coin recipienter can withdraw\n  tick_spacing: number\n  recipient: SuiAddressType\n  purchase_summary: {\n    purchase_handle: string\n    size: number\n  }\n  reality_raise_total: string\n  pool_status: LaunchpadPoolActivityState\n}\n\nexport type LaunchpadPool = LaunchpadPoolImmutables & LaunchpadPoolState\n\nexport enum LaunchpadPoolActivityState {\n  Upcoming = 'Upcoming',\n  Live = 'Live',\n  Settle = 'Settle',\n  Ended = 'Ended',\n  Failed = 'Failed',\n  Canceled = 'Canceled',\n}\n\nexport type CreateLaunchpadPoolParams = {\n  recipient: SuiObjectIdType // 项目方地址\n  initialize_price: string // ido初始价格\n  sale_total: string // 发行总量\n  min_purchase: string // 用户最小申购量\n  max_purchase: string // 用户最大申购量\n  least_raise_amount: string // 最小众筹数量（未达到ido失败）\n  hardcap: string\n  liquidity_rate: number // 流动性添加比例\n  start_time: number // ido开始时间\n  activity_duration: number // 活动周期\n  settle_duration: number // 结算周期\n  locked_duration: number // 锁仓周期\n  sale_decimals: number\n  raise_decimals: number\n  tick_spacing: number\n} & LaunchpadCoinPairType\n\nexport type PurchaseParams = {\n  pool_address: SuiObjectIdType\n  purchase_amount: string\n} & LaunchpadCoinPairType\n\nexport type ClaimParams = {\n  pool_address: SuiObjectIdType\n} & LaunchpadCoinPairType\n\nexport type SettleParams = {\n  pool_address: SuiObjectIdType\n  clmm_args?: {\n    clmm_pool_address: SuiObjectIdType\n    current_price: string\n    clmm_sqrt_price: string\n    sale_decimals: number\n    raise_decimals: number\n    opposite: boolean\n  }\n} & LaunchpadCoinPairType\n\nexport type SettleForCreateClmmPoolParams = {\n  pool_address: SuiObjectIdType\n  recipient: SuiObjectIdType\n  tick_spacing: string\n  initialize_sqrt_price: string\n  uri: string\n} & LaunchpadCoinPairType\n\nexport type WithdrawParams = {\n  pool_address: SuiObjectIdType\n  sale_amount: bigint\n  raise_amount: bigint\n} & LaunchpadCoinPairType\n\nexport type AddUserToWhitelistParams = {\n  pool_address: SuiObjectIdType\n  user_addrs: SuiObjectIdType[]\n  safe_limit_amount: string\n} & LaunchpadCoinPairType\n\nexport type UpdateWhitelistCapParams = {\n  pool_address: SuiObjectIdType\n  white_list_member: SuiObjectIdType\n  safe_limit_amount: number\n  hard_cap_total: number // hard_cap_total < hardcap\n} & LaunchpadCoinPairType\n\nexport type RemoveWhitelistParams = {\n  pool_address: SuiObjectIdType\n  user_addrs: SuiObjectIdType[]\n} & LaunchpadCoinPairType\n\nexport type UnlockNftParams = {\n  lock_nft: SuiObjectIdType\n  nft_type: SuiAddressType\n}\n\nexport type CancelParams = {\n  pool_address: SuiObjectIdType\n} & LaunchpadCoinPairType\n\nexport type UpdateRecipientParams = {\n  pool_address: SuiObjectIdType\n  new_recipient: SuiObjectIdType\n} & LaunchpadCoinPairType\n\nexport type UpdatePoolDurationParams = {\n  pool_address: SuiObjectIdType\n  activity_duration: number\n  settle_duration: number\n  lock_duration: number\n} & LaunchpadCoinPairType\n\nexport type PurchaseMark = {\n  id: SuiObjectIdType\n  pool_id: SuiObjectIdType\n  /// Purchase total raise amount\n  purchase_total: string\n  /// Claim get sale amount\n  obtain_sale_amount: string\n  /// Claim draw raise amount\n  used_raise_amount: string\n}\n\nexport type SettleEvent = {\n  pool_id: SuiObjectIdType\n  settle_price: string\n  unused_sale: string\n  unused_raise: string\n  white_purchase_total: string\n}\n","/* eslint-disable camelcase */\nimport BN from 'bn.js'\nimport Decimal from 'decimal.js'\nimport { TickMath } from './tick'\nimport { MathUtil } from './utils'\n\nconst D365 = new BN(365)\nconst H24 = new BN(24)\nconst S3600 = new BN(3600)\nconst B05 = new BN(0.5)\n\nexport function estPoolAPR(preBlockReward: BN, rewardPrice: BN, totalTradingFee: BN, totalLiquidityValue: BN): BN {\n  const annualRate = D365.mul(H24).mul(S3600).mul(B05)\n\n  const APR = annualRate.mul(preBlockReward.mul(rewardPrice).add(totalTradingFee).div(totalLiquidityValue))\n\n  return APR\n}\n\nfunction calculatePoolValidTVL(\n  amountA: BN,\n  amountB: BN,\n  decimalsA: number,\n  decimalsB: number,\n  coinAPrice: Decimal,\n  coinBPrice: Decimal\n): Decimal {\n  // console.log({\n  //   coinAmountsA: amountA.toString(),\n  //   coinAmountsB: amountB.toString(),\n  // })\n  const poolValidAmountA = new Decimal(amountA.toString()).div(new Decimal(10 ** decimalsA))\n  const poolValidAmountB = new Decimal(amountB.toString()).div(new Decimal(10 ** decimalsB))\n\n  // console.log(poolValidAmountA, poolValidAmountB)\n  const TVL = poolValidAmountA.mul(coinAPrice).add(poolValidAmountB.mul(coinBPrice))\n\n  return TVL\n}\n\nexport type estPosAPRResult = {\n  feeAPR: Decimal\n  posRewarder0APR: Decimal\n  posRewarder1APR: Decimal\n  posRewarder2APR: Decimal\n}\n\nexport function estPositionAPRWithDeltaMethod(\n  currentTickIndex: number,\n  lowerTickIndex: number,\n  upperTickIndex: number,\n  currentSqrtPriceX64: BN,\n  poolLiquidity: BN,\n  decimalsA: number,\n  decimalsB: number,\n  decimalsRewarder0: number,\n  decimalsRewarder1: number,\n  decimalsRewarder2: number,\n  feeRate: number,\n  amountA_str: string,\n  amountB_str: string,\n  poolAmountA: BN,\n  poolAmountB: BN,\n  swapVolume_str: string,\n  poolRewarders0_str: string,\n  poolRewarders1_str: string,\n  poolRewarders2_str: string,\n  coinAPrice_str: string,\n  coinBPrice_str: string,\n  rewarder0Price_str: string,\n  rewarder1Price_str: string,\n  rewarder2Price_str: string\n): estPosAPRResult {\n  const amountA = new Decimal(amountA_str)\n  const amountB = new Decimal(amountB_str)\n  const swapVolume = new Decimal(swapVolume_str)\n  const poolRewarders0 = new Decimal(poolRewarders0_str)\n  const poolRewarders1 = new Decimal(poolRewarders1_str)\n  const poolRewarders2 = new Decimal(poolRewarders2_str)\n  const coinAPrice = new Decimal(coinAPrice_str)\n  const coinBPrice = new Decimal(coinBPrice_str)\n  const rewarder0Price = new Decimal(rewarder0Price_str)\n  const rewarder1Price = new Decimal(rewarder1Price_str)\n  const rewarder2Price = new Decimal(rewarder2Price_str)\n\n  const lowerSqrtPriceX64 = TickMath.tickIndexToSqrtPriceX64(lowerTickIndex)\n  const upperSqrtPriceX64 = TickMath.tickIndexToSqrtPriceX64(upperTickIndex)\n  const lowerSqrtPrice_d = MathUtil.toX64_Decimal(MathUtil.fromX64(lowerSqrtPriceX64)).round()\n  const upperSqrtPrice_d = MathUtil.toX64_Decimal(MathUtil.fromX64(upperSqrtPriceX64)).round()\n  const currentSqrtPrice_d = MathUtil.toX64_Decimal(MathUtil.fromX64(currentSqrtPriceX64)).round()\n  let deltaLiquidity\n  const liquidityAmount0 = amountA\n    .mul(new Decimal(10 ** decimalsA))\n    .mul(upperSqrtPrice_d.mul(lowerSqrtPrice_d))\n    .div(upperSqrtPrice_d.sub(lowerSqrtPrice_d))\n    .round()\n  const liquidityAmount1 = amountB\n    .mul(new Decimal(10 ** decimalsB))\n    .div(upperSqrtPrice_d.sub(lowerSqrtPrice_d))\n    .round()\n  if (currentTickIndex < lowerTickIndex) {\n    deltaLiquidity = liquidityAmount0\n  } else if (currentTickIndex > upperTickIndex) {\n    deltaLiquidity = liquidityAmount1\n  } else {\n    deltaLiquidity = Decimal.min(liquidityAmount0, liquidityAmount1)\n  }\n  const deltaY = deltaLiquidity.mul(currentSqrtPrice_d.sub(lowerSqrtPrice_d))\n  const deltaX = deltaLiquidity.mul(upperSqrtPrice_d.sub(currentSqrtPrice_d)).div(currentSqrtPrice_d.mul(upperSqrtPrice_d))\n  const posValidTVL = deltaX\n    .div(new Decimal(10 ** decimalsA))\n    .mul(coinAPrice)\n    .add(deltaY.div(new Decimal(10 ** decimalsB).mul(coinBPrice)))\n  const poolValidTVL = calculatePoolValidTVL(poolAmountA, poolAmountB, decimalsA, decimalsB, coinAPrice, coinBPrice)\n  const posValidRate = posValidTVL.div(poolValidTVL)\n\n  const feeAPR = deltaLiquidity.eq(new Decimal(0))\n    ? new Decimal(0)\n    : new Decimal(feeRate / 10000)\n        .mul(swapVolume)\n        .mul(new Decimal(deltaLiquidity.toString()).div(new Decimal(poolLiquidity.toString()).add(new Decimal(deltaLiquidity.toString()))))\n        .div(posValidTVL)\n\n  const aprCoe = posValidRate.eq(new Decimal(0)) ? new Decimal(0) : posValidRate.mul(new Decimal(36500 / 7)).div(posValidTVL)\n  const posRewarder0APR = poolRewarders0\n    .div(new Decimal(10 ** decimalsRewarder0))\n    .mul(rewarder0Price)\n    .mul(aprCoe)\n  const posRewarder1APR = poolRewarders1\n    .div(new Decimal(10 ** decimalsRewarder1))\n    .mul(rewarder1Price)\n    .mul(aprCoe)\n  const posRewarder2APR = poolRewarders2\n    .div(new Decimal(10 ** decimalsRewarder2))\n    .mul(rewarder2Price)\n    .mul(aprCoe)\n  return {\n    feeAPR,\n    posRewarder0APR,\n    posRewarder1APR,\n    posRewarder2APR,\n  }\n}\n\nexport function estPositionAPRWithMultiMethod(\n  lowerUserPrice: number,\n  upperUserPrice: number,\n  lowerHistPrice: number,\n  upperHistPrice: number\n): Decimal {\n  const retroLower = Math.max(lowerUserPrice, lowerHistPrice)\n  const retroUpper = Math.min(upperUserPrice, upperHistPrice)\n  const retroRange = retroUpper - retroLower\n  const userRange = upperUserPrice - lowerUserPrice\n  const histRange = upperHistPrice - lowerHistPrice\n  const userRange_d = new Decimal(userRange.toString())\n  const histRange_d = new Decimal(histRange.toString())\n  const retroRange_d = new Decimal(retroRange.toString())\n\n  let m = new Decimal('0')\n  if (retroRange < 0) {\n    m = new Decimal('0')\n  } else if (userRange === retroRange) {\n    m = histRange_d.div(retroRange_d)\n  } else if (histRange === retroRange) {\n    m = retroRange_d.div(userRange_d)\n  } else {\n    m = retroRange_d.mul(retroRange_d).div(histRange_d).div(userRange_d)\n  }\n\n  return m\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@syntsugar/cc-graph\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"js-base64\");"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","require","SwapErrorCode","PoolErrorCode","CoinErrorCode","MathErrorCode","precision","rounding","toExpNeg","toExpPos","Error","message","errorCode","constructor","super","this","static","e","code","TWO","AmountSpecified","PositionStatus","SwapDirection","SplitUnit","LaunchpadPoolActivityState","pow","sub"],"sourceRoot":""}